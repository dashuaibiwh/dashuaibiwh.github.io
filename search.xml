<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[筛法素数]]></title>
    <url>%2F2017%2F10%2F07%2F%E7%AD%9B%E6%B3%95%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[数论第一步，从素数开始.写在前面： 由于月底要去西安参加比赛啦QWQ。要提前开始打板子啦。之前的计划这么快就要提前开始了。在队里负责数论这一块。暑假才开始接触数论，还是有点方。希望这一个月能深入一下吧。 首先贴一个线性筛。O（n）1234567891011121314void init()&#123; for(int i=2;i&lt;N;i++)&#123; prime[i]=true; &#125; for(int i=2;i&lt;N;i++)&#123; if(prime[i]) p[tot++] = i; for(int j=0;j&lt;tot &amp;&amp; i*p[j]&lt;N; j++)&#123; prime[i*p[j]]=false; if(i%p[j] == 0) break; &#125; &#125; &#125; 是个写烂了的模板。偶然在某个blog上看到了应用123456789101112131415161718192021222324252627282930313233343536373839/*筛法的应用*/ //预处理每个数的所有质因数vector&lt;int&gt; prime_factor[N];void init1()&#123; for(int i = 2; i &lt; N; i++)&#123; if(prime_factor[i].size() == 0)&#123; for(int j = i; j &lt; N; j += i)&#123; prime_factor[j].push_back(i); &#125; &#125; &#125;&#125; //预处理每个数的所有因数 vector&lt;int&gt; factor[N];void init2()&#123; for(int i = 2; i &lt; N; i++)&#123; for(int j = i; j &lt; N; j += i)&#123; factor[j].push_back(i); &#125; &#125;&#125;//预处理每个数的质因数分解vector&lt;int&gt; factor_prime[N];void init3()&#123; int temp; for(int i = 2; i &lt; N; i++)&#123; if(factor_prime[i].size() == 0)&#123; for(int j = i; j &lt; N; j+=i)&#123; temp=j; while(temp % i == 0)&#123; factor_prime[j].push_back(i); temp /= i; &#125; &#125; &#125; &#125;&#125; 这里就是巩固了一下STL中vector的用法。我是记不太清了。所以刚好复习了一下。 最后贴个输出123456789101112int main()&#123; //每个数的质因数 init1(); for(int i=2;i&lt;N;i++)&#123; for(int j=0;j&lt;prime_factor[i].size();j++)&#123; cout&lt;&lt;prime_factor[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[This is dashuaibi]]></content>
  </entry>
</search>
